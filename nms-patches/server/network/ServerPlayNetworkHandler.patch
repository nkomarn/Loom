--- a/net/minecraft/server/network/ServerPlayNetworkHandler.java
+++ b/net/minecraft/server/network/ServerPlayNetworkHandler.java
@@ -33,6 +33,8 @@
 import net.minecraft.entity.JumpingMount;
 import net.minecraft.entity.MovementType;
 import net.minecraft.entity.effect.StatusEffects;
+import net.minecraft.entity.mob.MobEntity;
+import net.minecraft.entity.passive.FishEntity;
 import net.minecraft.entity.passive.HorseBaseEntity;
 import net.minecraft.entity.player.PlayerInventory;
 import net.minecraft.entity.projectile.PersistentProjectileEntity;
@@ -96,25 +98,18 @@
 import net.minecraft.network.packet.c2s.play.UpdateSignC2SPacket;
 import net.minecraft.network.packet.c2s.play.UpdateStructureBlockC2SPacket;
 import net.minecraft.network.packet.c2s.play.VehicleMoveC2SPacket;
-import net.minecraft.network.packet.s2c.play.BlockUpdateS2CPacket;
-import net.minecraft.network.packet.s2c.play.CommandSuggestionsS2CPacket;
-import net.minecraft.network.packet.s2c.play.ConfirmGuiActionS2CPacket;
-import net.minecraft.network.packet.s2c.play.DisconnectS2CPacket;
-import net.minecraft.network.packet.s2c.play.GameMessageS2CPacket;
-import net.minecraft.network.packet.s2c.play.HeldItemChangeS2CPacket;
-import net.minecraft.network.packet.s2c.play.KeepAliveS2CPacket;
-import net.minecraft.network.packet.s2c.play.PlayerPositionLookS2CPacket;
-import net.minecraft.network.packet.s2c.play.ScreenHandlerSlotUpdateS2CPacket;
-import net.minecraft.network.packet.s2c.play.TagQueryResponseS2CPacket;
-import net.minecraft.network.packet.s2c.play.VehicleMoveS2CPacket;
+import net.minecraft.network.packet.s2c.play.*;
+import net.minecraft.recipe.Recipe;
 import net.minecraft.screen.AbstractRecipeScreenHandler;
 import net.minecraft.screen.AnvilScreenHandler;
 import net.minecraft.screen.BeaconScreenHandler;
 import net.minecraft.screen.MerchantScreenHandler;
 import net.minecraft.screen.ScreenHandler;
 import net.minecraft.screen.slot.Slot;
+import net.minecraft.screen.slot.SlotActionType;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.command.ServerCommandSource;
+import net.minecraft.server.world.ServerWorld;
 import net.minecraft.text.LiteralText;
 import net.minecraft.text.MutableText;
 import net.minecraft.text.Text;
@@ -131,21 +126,60 @@
 import net.minecraft.util.crash.CrashReportSection;
 import net.minecraft.util.function.BooleanBiFunction;
 import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.hit.HitResult;
+import net.minecraft.util.math.*;
 import net.minecraft.util.shape.VoxelShape;
 import net.minecraft.util.shape.VoxelShapes;
-import net.minecraft.world.CommandBlockExecutor;
-import net.minecraft.world.GameMode;
-import net.minecraft.world.GameRules;
-import net.minecraft.world.World;
-import net.minecraft.world.WorldView;
+import net.minecraft.world.*;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+// CraftBukkit start
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.craftbukkit.util.LazyPlayerSet;
+import org.bukkit.craftbukkit.util.Waitable;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Event;
+import org.bukkit.event.block.Action;
+import org.bukkit.event.block.SignChangeEvent;
+import org.bukkit.event.inventory.ClickType;
+import org.bukkit.event.inventory.CraftItemEvent;
+import org.bukkit.event.inventory.InventoryAction;
+import org.bukkit.event.inventory.InventoryClickEvent;
+import org.bukkit.event.inventory.InventoryCreativeEvent;
+import org.bukkit.event.inventory.InventoryType.SlotType;
+import org.bukkit.event.player.AsyncPlayerChatEvent;
+import org.bukkit.event.player.PlayerAnimationEvent;
+import org.bukkit.event.player.PlayerChatEvent;
+import org.bukkit.event.player.PlayerCommandPreprocessEvent;
+import org.bukkit.event.player.PlayerInteractAtEntityEvent;
+import org.bukkit.event.player.PlayerInteractEntityEvent;
+import org.bukkit.event.player.PlayerItemHeldEvent;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.bukkit.event.player.PlayerMoveEvent;
+import org.bukkit.event.player.PlayerResourcePackStatusEvent;
+import org.bukkit.event.player.PlayerSwapHandItemsEvent;
+import org.bukkit.event.player.PlayerTeleportEvent;
+import org.bukkit.event.player.PlayerToggleFlightEvent;
+import org.bukkit.event.player.PlayerToggleSneakEvent;
+import org.bukkit.event.player.PlayerToggleSprintEvent;
+import org.bukkit.inventory.CraftingInventory;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.util.NumberConversions;
+// CraftBukkit end
+
 public class ServerPlayNetworkHandler implements ServerPlayPacketListener {
 
     private static final Logger LOGGER = LogManager.getLogger();
@@ -156,7 +190,10 @@
     private long lastKeepAliveTime;
     private boolean waitingForKeepAlive;
     private long keepAliveId;
-    private int messageCooldown;
+    // CraftBukkit start - multithreaded fields
+    private volatile int messageCooldown;
+    private static final AtomicIntegerFieldUpdater chatSpamField = AtomicIntegerFieldUpdater.newUpdater(ServerPlayNetworkHandler.class, "messageCooldown");
+    // CraftBukkit end
     private int creativeItemDropThreshold;
     private final Int2ShortMap transactions = new Int2ShortOpenHashMap();
     private double lastTickX;
@@ -182,12 +219,32 @@
     private int movePacketsCount;
     private int lastTickMovePacketsCount;
 
+    private final org.bukkit.craftbukkit.CraftServer craftServer;
+    public boolean processedDisconnect;
+    private int lastTick = MinecraftServer.currentTick;
+    private int allowedPlayerTicks = 1;
+    private int lastDropTick = MinecraftServer.currentTick;
+    private int lastBookTick  = MinecraftServer.currentTick;
+    private int dropCount = 0;
+    private static final int SURVIVAL_PLACE_DISTANCE_SQUARED = 6 * 6;
+    private static final int CREATIVE_PLACE_DISTANCE_SQUARED = 7 * 7;
+
+    // Get position of last block hit for BlockDamageLevel.STOPPED
+    private double lastPosX = Double.MAX_VALUE;
+    private double lastPosY = Double.MAX_VALUE;
+    private double lastPosZ = Double.MAX_VALUE;
+    private float lastPitch = Float.MAX_VALUE;
+    private float lastYaw = Float.MAX_VALUE;
+    private boolean justTeleported = false;
+
     public ServerPlayNetworkHandler(MinecraftServer minecraftserver, ClientConnection clientconnection, ServerPlayerEntity serverplayerentity) {
         this.server = minecraftserver;
         this.connection = clientconnection;
         clientconnection.setPacketListener(this);
         this.player = serverplayerentity;
         serverplayerentity.networkHandler = this;
+        // CraftBukkit start - add fields and methods
+        this.craftServer = minecraftserver.server;
     }
 
     public void tick() {
@@ -237,7 +294,7 @@
         this.server.getProfiler().push("keepAlive");
         long i = Util.getMeasuringTimeMs();
 
-        if (i - this.lastKeepAliveTime >= 15000L) {
+        if (i - this.lastKeepAliveTime >= 25000L) { // CraftBukkit
             if (this.waitingForKeepAlive) {
                 this.disconnect(new TranslatableText("disconnect.timeout"));
             } else {
@@ -247,20 +304,25 @@
                 this.sendPacket(new KeepAliveS2CPacket(this.keepAliveId));
             }
         }
-
+        // CraftBukkit start
+        for (int spam; (spam = this.messageCooldown) > 0 && !chatSpamField.compareAndSet(this, spam, spam - 1); ) ;
+        /* Use thread-safe field access instead
         this.server.getProfiler().pop();
         if (this.messageCooldown > 0) {
             --this.messageCooldown;
         }
+        */
+        // CraftBukkit end
 
         if (this.creativeItemDropThreshold > 0) {
             --this.creativeItemDropThreshold;
         }
 
         if (this.player.getLastActionTime() > 0L && this.server.getPlayerIdleTimeout() > 0 && Util.getMeasuringTimeMs() - this.player.getLastActionTime() > (long) (this.server.getPlayerIdleTimeout() * 1000 * 60)) {
+            this.player.updateLastActionTime(); // CraftBukkit - SPIGOT-854
             this.disconnect(new TranslatableText("multiplayer.disconnect.idling"));
         }
-
+        // TODO -- addspigot code? SpigotTimings.playerConnectionTimer.stopTiming();
     }
 
     public void syncWithPlayerPosition() {
@@ -280,16 +342,43 @@
         return this.server.isHost(this.player.getGameProfile());
     }
 
+    @Deprecated
     public void disconnect(Text text) {
+        disconnect(CraftChatMessage.fromComponent(text));
+    }
+
+    public void disconnect(String s) {
+        // CraftBukkit start - fire PlayerKickEvent
+        if (this.processedDisconnect) {
+            return;
+        }
+        String leaveMessage = Formatting.YELLOW + this.player.getName().asString() + " left the game.";
+        PlayerKickEvent event = new PlayerKickEvent(this.craftServer.getPlayer(this.player), s, leaveMessage);
+
+        if (this.server.isRunning()) {
+            Bukkit.getPluginManager().callEvent(event);
+        }
+
+        if (event.isCancelled()) {
+            // Do not kick the player
+            return;
+        }
+        // Send the possibly modified leave message
+        s = event.getReason();
+        // CraftBukkit end
+        final Text text = new LiteralText(s);
+
         this.connection.send(new DisconnectS2CPacket(text), (future) -> {
             this.connection.disconnect(text);
         });
+        this.onDisconnected(text);
         this.connection.disableAutoRead();
         MinecraftServer minecraftserver = this.server;
         ClientConnection clientconnection = this.connection;
 
         this.connection.getClass();
-        minecraftserver.submitAndJoin(clientconnection::handleDisconnection);
+        // CraftBukkit - Don't wait
+        minecraftserver.createTask(clientconnection::handleDisconnection);
     }
 
     public void onPlayerInput(PlayerInputC2SPacket playerinputc2spacket) {
@@ -328,7 +417,34 @@
                 double d9 = entity.getVelocity().lengthSquared();
                 double d10 = d6 * d6 + d7 * d7 + d8 * d8;
 
-                if (d10 - d9 > 100.0D && !this.isHost()) {
+
+                // CraftBukkit start - handle custom speeds and skipped ticks
+                this.allowedPlayerTicks += (System.currentTimeMillis() / 50) - this.lastTick;
+                this.allowedPlayerTicks = Math.max(this.allowedPlayerTicks, 1);
+                this.lastTick = (int) (System.currentTimeMillis() / 50);
+
+                ++this.movePacketsCount;
+                int i = this.movePacketsCount - this.lastTickMovePacketsCount;
+                if (i > Math.max(this.allowedPlayerTicks, 5)) {
+                    ServerPlayNetworkHandler.LOGGER.debug(this.player.getName() + " is sending move packets too frequently (" + i + " packets since last tick)");
+                    i = 1;
+                }
+
+                if (d10 > 0) {
+                    allowedPlayerTicks -= 1;
+                } else {
+                    allowedPlayerTicks = 20;
+                }
+                double speed;
+                if (player.abilities.flying) {
+                    speed = player.abilities.flySpeed * 20f;
+                } else {
+                    speed = player.abilities.walkSpeed * 10f;
+                }
+                speed *= 2f; // TODO: Get the speed of the vehicle instead of the player
+
+                if (d10 - d9 > Math.max(100.0D, Math.pow((double) (10.0F * (float) i * speed), 2)) && !this.isHost()) {
+                // CraftBukkit end
                     ServerPlayNetworkHandler.LOGGER.warn("{} (vehicle of {}) moved too quickly! {},{},{}", (Object) entity.getName().getString(), this.player.getName().getString(), d6, d7, d8);
                     this.connection.send(new VehicleMoveS2CPacket(entity));
                     return;
@@ -358,14 +474,72 @@
                 }
 
                 entity.updatePositionAndAngles(d3, d4, d5, f, f1);
+                player.updatePositionAndAngles(d3, d4, d5, this.player.yaw, this.player.pitch); // CraftBukkit
                 boolean flag2 = serverworld.doesNotCollide(entity, entity.getBoundingBox().contract(0.0625D));
 
                 if (flag && (flag1 || !flag2)) {
                     entity.updatePositionAndAngles(d0, d1, d2, f, f1);
+                    player.updatePositionAndAngles(d0, d1, d2, this.player.yaw, this.player.pitch); // CraftBukkit
                     this.connection.send(new VehicleMoveS2CPacket(entity));
                     return;
                 }
 
+                // CraftBukkit start - fire PlayerMoveEvent
+                Player player = this.getPlayer();
+                Location from = new Location(player.getWorld(), lastPosX, lastPosY, lastPosZ, lastYaw, lastPitch); // Get the Players previous Event location.
+                Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
+
+                // If the packet contains movement information then we update the To location with the correct XYZ.
+                to.setX(vehiclemovec2spacket.getX());
+                to.setY(vehiclemovec2spacket.getY());
+                to.setZ(vehiclemovec2spacket.getZ());
+
+
+                // If the packet contains look information then we update the To location with the correct Yaw & Pitch.
+                to.setYaw(vehiclemovec2spacket.getYaw());
+                to.setPitch(vehiclemovec2spacket.getPitch());
+
+                // Prevent 40 event-calls for less than a single pixel of movement >.>
+                double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
+                float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
+
+                if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isFrozen()) {
+                    this.lastPosX = to.getX();
+                    this.lastPosY = to.getY();
+                    this.lastPosZ = to.getZ();
+                    this.lastYaw = to.getYaw();
+                    this.lastPitch = to.getPitch();
+
+                    // Skip the first time we do this
+                    if (from.getX() != Double.MAX_VALUE) {
+                        Location oldTo = to.clone();
+                        PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
+                        Bukkit.getPluginManager().callEvent(event);
+
+                        // If the event is cancelled we move the player back to their old location.
+                        if (event.isCancelled()) {
+                            teleport(from);
+                            return;
+                        }
+
+                        // If a Plugin has changed the To destination then we teleport the Player
+                        // there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
+                        // We only do this if the Event was not cancelled.
+                        if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
+                            this.player.getBukkitEntity().teleport(event.getTo(), PlayerTeleportEvent.TeleportCause.PLUGIN);
+                            return;
+                        }
+
+                        // Check to see if the Players Location has some how changed during the call of the event.
+                        // This can happen due to a plugin teleporting the player instead of using .setTo()
+                        if (!from.equals(this.getPlayer().getLocation()) && this.justTeleported) {
+                            this.justTeleported = false;
+                            return;
+                        }
+                    }
+                }
+                // CraftBukkit end
+
                 this.player.getServerWorld().getChunkManager().updateCameraPosition(this.player);
                 this.player.increaseTravelMotionStats(this.player.getX() - d0, this.player.getY() - d1, this.player.getZ() - d2);
                 this.ridingEntity = d11 >= -0.03125D && !this.server.isFlightEnabled() && this.method_29780(entity);
@@ -383,7 +557,7 @@
 
     public void onTeleportConfirm(TeleportConfirmC2SPacket teleportconfirmc2spacket) {
         NetworkThreadUtils.forceMainThread(teleportconfirmc2spacket, this, this.player.getServerWorld());
-        if (teleportconfirmc2spacket.getTeleportId() == this.requestedTeleportId) {
+        if (teleportconfirmc2spacket.getTeleportId() == this.requestedTeleportId  && this.requestedTeleportPos != null) { // CraftBukkit
             this.player.updatePositionAndAngles(this.requestedTeleportPos.x, this.requestedTeleportPos.y, this.requestedTeleportPos.z, this.player.yaw, this.player.pitch);
             this.updatedX = this.requestedTeleportPos.x;
             this.updatedY = this.requestedTeleportPos.y;
@@ -393,6 +567,7 @@
             }
 
             this.requestedTeleportPos = null;
+            this.player.getServerWorld().getChunkManager().updateCameraPosition(this.player); // CraftBukkit
         }
 
     }
@@ -400,8 +575,8 @@
     public void onRecipeBookData(RecipeBookDataC2SPacket recipebookdatac2spacket) {
         NetworkThreadUtils.forceMainThread(recipebookdatac2spacket, this, this.player.getServerWorld());
         if (recipebookdatac2spacket.getMode() == RecipeBookDataC2SPacket.Mode.SHOWN) {
-            Optional optional = this.server.getRecipeManager().get(recipebookdatac2spacket.getRecipeId());
-            ServerRecipeBook serverrecipebook = this.player.getRecipeBook();
+            Optional<? extends Recipe<?>>  optional = this.server.getRecipeManager().get(recipebookdatac2spacket.getRecipeId());
+            ServerRecipeBook serverrecipebook = this.player.getRecipeBook(); // CraftBukkit - decompile error
 
             optional.ifPresent(serverrecipebook::onRecipeDisplayed);
         } else if (recipebookdatac2spacket.getMode() == RecipeBookDataC2SPacket.Mode.SETTINGS) {
@@ -432,6 +607,12 @@
 
     public void onRequestCommandCompletions(RequestCommandCompletionsC2SPacket requestcommandcompletionsc2spacket) {
         NetworkThreadUtils.forceMainThread(requestcommandcompletionsc2spacket, this, this.player.getServerWorld());
+        // CraftBukkit start
+        if (chatSpamField.addAndGet(this, 1) > 500 && !this.server.getPlayerManager().isOperator(this.player.getGameProfile())) {
+            this.disconnect(new TranslatableText("disconnect.spam", new Object[0]));
+            return;
+        }
+        // CraftBukkit end
         StringReader stringreader = new StringReader(requestcommandcompletionsc2spacket.getPartialCommand());
 
         if (stringreader.canRead() && stringreader.peek() == '/') {
@@ -441,6 +622,7 @@
         ParseResults<ServerCommandSource> parseresults = this.server.getCommandManager().getDispatcher().parse(stringreader, this.player.getCommandSource());
 
         this.server.getCommandManager().getDispatcher().getCompletionSuggestions(parseresults).thenAccept((suggestions) -> {
+            if (suggestions.isEmpty()) return; // CraftBukkit - don't send through empty suggestions - prevents [<args>] from showing for plugins with nothing more to offer
             this.connection.send(new CommandSuggestionsS2CPacket(requestcommandcompletionsc2spacket.getCompletionId(), suggestions));
         });
     }
@@ -660,6 +842,7 @@
 
         if (screenhandler instanceof MerchantScreenHandler) {
             MerchantScreenHandler merchantscreenhandler = (MerchantScreenHandler) screenhandler;
+            CraftEventFactory.callTradeSelectEvent(this.player, i, merchantscreenhandler); // CraftBukkit
 
             merchantscreenhandler.setRecipeIndex(i);
             merchantscreenhandler.switchTo(i);
@@ -669,6 +852,14 @@
 
     public void onBookUpdate(BookUpdateC2SPacket bookupdatec2spacket) {
         NetworkThreadUtils.forceMainThread(bookupdatec2spacket, this, this.player.getServerWorld());
+        // CraftBukkit start
+        if (this.lastBookTick + 20 > MinecraftServer.currentTick) {
+            this.disconnect("Book edited too quickly!");
+            return;
+        }
+        this.lastBookTick = MinecraftServer.currentTick;
+        EquipmentSlot enumitemslot = bookupdatec2spacket.getHand() == Hand.MAIN_HAND ? EquipmentSlot.HAND : EquipmentSlot.OFF_HAND;
+        // CraftBukkit end
         ItemStack itemstack = bookupdatec2spacket.getBook();
 
         if (!itemstack.isEmpty()) {
@@ -697,9 +888,11 @@
                         }
 
                         itemstack2.putSubTag("pages", listtag);
-                        this.player.setStackInHand(bookupdatec2spacket.getHand(), itemstack2);
+                        this.player.setStackInHand(bookupdatec2spacket.getHand(), CraftEventFactory.handleEditBookEvent(player, enumitemslot, itemstack1, itemstack2)); // CraftBukkit
                     } else {
+                        ItemStack old = itemstack1.copy(); // CraftBukkit
                         itemstack1.putSubTag("pages", itemstack.getTag().getList("pages", 8));
+                        CraftEventFactory.handleEditBookEvent(player, enumitemslot, old, itemstack1); // CraftBukkit
                     }
                 }
 
@@ -738,7 +931,7 @@
         } else {
             ServerWorld serverworld = this.player.getServerWorld();
 
-            if (!this.player.notInAnyWorld) {
+            if (!this.player.notInAnyWorld && !this.player.isFrozen()) { // CraftBukkit
                 if (this.ticks == 0) {
                     this.syncWithPlayerPosition();
                 }
@@ -748,13 +941,21 @@
                         this.teleportRequestTick = this.ticks;
                         this.requestTeleport(this.requestedTeleportPos.x, this.requestedTeleportPos.y, this.requestedTeleportPos.z, this.player.yaw, this.player.pitch);
                     }
-
+                    this.allowedPlayerTicks = 20; // CraftBukkit
                 } else {
                     this.teleportRequestTick = this.ticks;
                     if (this.player.hasVehicle()) {
                         this.player.updatePositionAndAngles(this.player.getX(), this.player.getY(), this.player.getZ(), playermovec2spacket.getYaw(this.player.yaw), playermovec2spacket.getPitch(this.player.pitch));
                         this.player.getServerWorld().getChunkManager().updateCameraPosition(this.player);
+                        this.allowedPlayerTicks = 20; // CraftBukkit
                     } else {
+                        // CraftBukkit - Make sure the move is valid but then reset it for plugins to modify
+                        double prevX = player.getX();
+                        double prevY = player.getY();
+                        double prevZ = player.getZ();
+                        float prevYaw = player.yaw;
+                        float prevPitch = player.pitch;
+                        // CraftBukkit end
                         double d0 = this.player.getX();
                         double d1 = this.player.getY();
                         double d2 = this.player.getZ();
@@ -778,16 +979,33 @@
                         } else {
                             ++this.movePacketsCount;
                             int i = this.movePacketsCount - this.lastTickMovePacketsCount;
+                            // CraftBukkit start - handle custom speeds and skipped ticks
+                            this.allowedPlayerTicks += (System.currentTimeMillis() / 50) - this.lastTick;
+                            this.allowedPlayerTicks = Math.max(this.allowedPlayerTicks, 1);
+                            this.lastTick = (int) (System.currentTimeMillis() / 50);
 
-                            if (i > 5) {
+                            if (i > Math.max(this.allowedPlayerTicks, 5)) {
                                 ServerPlayNetworkHandler.LOGGER.debug("{} is sending move packets too frequently ({} packets since last tick)", (Object) this.player.getName().getString(), (Object) i);
                                 i = 1;
                             }
 
+                            if (playermovec2spacket.changeLook || d11 > 0) {
+                                allowedPlayerTicks -= 1;
+                            } else {
+                                allowedPlayerTicks = 20;
+                            }
+                            double speed;
+                            if (player.abilities.flying) {
+                                speed = player.abilities.flySpeed * 20f;
+                            } else {
+                                speed = player.abilities.walkSpeed * 10f;
+                            }
+
                             if (!this.player.isInTeleportationState() && (!this.player.getServerWorld().getGameRules().getBoolean(GameRules.DISABLE_ELYTRA_MOVEMENT_CHECK) || !this.player.isFallFlying())) {
                                 float f2 = this.player.isFallFlying() ? 300.0F : 100.0F;
 
-                                if (d11 - d10 > (double) (f2 * (float) i) && !this.isHost()) {
+                                if (d11 - d10 > Math.max(f2, Math.pow((double) (10.0F * (float) i * speed), 2)) && !this.isHost()) {
+                                    // CraftBukkit end
                                     ServerPlayNetworkHandler.LOGGER.warn("{} moved too quickly! {},{},{}", (Object) this.player.getName().getString(), d7, d8, d9);
                                     this.requestTeleport(this.player.getX(), this.player.getY(), this.player.getZ(), this.player.yaw, this.player.pitch);
                                     return;
@@ -827,7 +1045,72 @@
                             if (!this.player.noClip && !this.player.isSleeping() && (flag1 && serverworld.doesNotCollide(this.player, box) || this.isPlayerNotCollidingWithBlocks(serverworld, box))) {
                                 this.requestTeleport(d0, d1, d2, f, f1);
                             } else {
-                                this.floating = d12 >= -0.03125D && this.player.interactionManager.getGameMode() != GameMode.SPECTATOR && !this.server.isFlightEnabled() && !this.player.abilities.allowFlying && !this.player.hasStatusEffect(StatusEffects.LEVITATION) && !this.player.isFallFlying() && this.method_29780(this.player);
+                                // CraftBukkit start - fire PlayerMoveEvent
+                                // Rest to old location first
+                                this.player.setLocation(prevX, prevY, prevZ, prevYaw, prevPitch);
+
+                                Player player = this.getPlayer();
+                                Location from = new Location(player.getWorld(), lastPosX, lastPosY, lastPosZ, lastYaw, lastPitch); // Get the Players previous Event location.
+                                Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
+
+                                // If the packet contains movement information then we update the To location with the correct XYZ.
+                                if (playermovec2spacket.changePosition) {
+                                    to.setX(playermovec2spacket.x);
+                                    to.setY(playermovec2spacket.y);
+                                    to.setZ(playermovec2spacket.z);
+                                }
+
+                                // If the packet contains look information then we update the To location with the correct Yaw & Pitch.
+                                if (playermovec2spacket.changeLook) {
+                                    to.setYaw(playermovec2spacket.yaw);
+                                    to.setPitch(playermovec2spacket.pitch);
+                                }
+
+                                // Prevent 40 event-calls for less than a single pixel of movement >.>
+                                double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
+                                float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
+
+                                if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isFrozen()) {
+                                    this.lastPosX = to.getX();
+                                    this.lastPosY = to.getY();
+                                    this.lastPosZ = to.getZ();
+                                    this.lastYaw = to.getYaw();
+                                    this.lastPitch = to.getPitch();
+
+                                    // Skip the first time we do this
+                                    if (from.getX() != Double.MAX_VALUE) {
+                                        Location oldTo = to.clone();
+                                        PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
+                                        Bukkit.getPluginManager().callEvent(event);
+
+                                        // If the event is cancelled we move the player back to their old location.
+                                        if (event.isCancelled()) {
+                                            teleport(from);
+                                            return;
+                                        }
+
+                                        // If a Plugin has changed the To destination then we teleport the Player
+                                        // there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
+                                        // We only do this if the Event was not cancelled.
+                                        if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
+                                            this.player.getBukkitEntity().teleport(event.getTo(), PlayerTeleportEvent.TeleportCause.PLUGIN);
+                                            return;
+                                        }
+
+                                        // Check to see if the Players Location has some how changed during the call of the event.
+                                        // This can happen due to a plugin teleporting the player instead of using .setTo()
+                                        if (!from.equals(this.getPlayer().getLocation()) && this.justTeleported) {
+                                            this.justTeleported = false;
+                                            return;
+                                        }
+                                    }
+                                }
+                                this.player.setLocation(d4, d5, d6, f, f1); // Copied from above
+
+                                // MC-135989, SPIGOT-5564: isRiptiding
+                                this.floating = d12 >= -0.03125D && this.player.interactionManager.getGameMode() != GameMode.SPECTATOR && !this.server.isFlightEnabled() && !this.player.abilities.allowFlying && !this.player.hasStatusEffect(StatusEffects.LEVITATION) && !this.player.isFallFlying() && this.method_29780(this.player) && !this.player.isUsingRiptide();
+                                // CraftBukkit end
+
                                 this.player.getServerWorld().getChunkManager().updateCameraPosition(this.player);
                                 this.player.handleFall(this.player.getY() - d3, playermovec2spacket.isOnGround());
                                 this.player.setOnGround(playermovec2spacket.isOnGround());
@@ -862,7 +1145,63 @@
         this.teleportRequest(d0, d1, d2, f, f1, Collections.emptySet());
     }
 
+    // CraftBukkit start - Delegate to teleport(Location)
+    public void teleportRequest(double d0, double d1, double d2, float f, float f1, PlayerTeleportEvent.TeleportCause cause) {
+        this.teleportRequest(d0, d1, d2, f, f1, Collections.emptySet(), cause);
+    }
+
     public void teleportRequest(double d0, double d1, double d2, float f, float f1, Set<PlayerPositionLookS2CPacket.Flag> set) {
+        this.teleportRequest(d0, d1, d2, f, f1, set, PlayerTeleportEvent.TeleportCause.UNKNOWN);
+    }
+
+    public void teleportRequest(double d0, double d1, double d2, float f, float f1, Set<PlayerPositionLookS2CPacket.Flag> set, PlayerTeleportEvent.TeleportCause cause) {
+        Player player = this.getPlayer();
+        Location from = player.getLocation();
+
+        double x = d0;
+        double y = d1;
+        double z = d2;
+        float yaw = f;
+        float pitch = f1;
+
+        Location to = new Location(this.getPlayer().getWorld(), x, y, z, yaw, pitch);
+        // SPIGOT-5171: Triggered on join
+        if (from.equals(to)) {
+            this.internalTeleport(d0, d1, d2, f, f1, set);
+            return;
+        }
+
+        PlayerTeleportEvent event = new PlayerTeleportEvent(player, from.clone(), to.clone(), cause);
+        Bukkit.getPluginManager().callEvent(event);
+
+        if (event.isCancelled() || !to.equals(event.getTo())) {
+            set.clear(); // Can't relative teleport
+            to = event.isCancelled() ? event.getFrom() : event.getTo();
+            d0 = to.getX();
+            d1 = to.getY();
+            d2 = to.getZ();
+            f = to.getYaw();
+            f1 = to.getPitch();
+        }
+
+        this.internalTeleport(d0, d1, d2, f, f1, set);
+    }
+
+    public void teleport(Location dest) {
+        internalTeleport(dest.getX(), dest.getY(), dest.getZ(), dest.getYaw(), dest.getPitch(), Collections.<PlayerPositionLookS2CPacket.Flag>emptySet());
+    }
+
+    private void internalTeleport(double d0, double d1, double d2, float f, float f1, Set<PlayerPositionLookS2CPacket.Flag> set) {
+        // CraftBukkit start
+        if (Float.isNaN(f)) {
+            f = 0;
+        }
+        if (Float.isNaN(f1)) {
+            f1 = 0;
+        }
+
+        this.justTeleported = true;
+        // CraftBukkit end
         double d3 = set.contains(PlayerPositionLookS2CPacket.Flag.X) ? this.player.getX() : 0.0D;
         double d4 = set.contains(PlayerPositionLookS2CPacket.Flag.Y) ? this.player.getY() : 0.0D;
         double d5 = set.contains(PlayerPositionLookS2CPacket.Flag.Z) ? this.player.getZ() : 0.0D;
@@ -874,6 +1213,14 @@
             this.requestedTeleportId = 0;
         }
 
+        // CraftBukkit start - update last location
+        this.lastPosX = this.requestedTeleportPos.x;
+        this.lastPosY = this.requestedTeleportPos.y;
+        this.lastPosZ = this.requestedTeleportPos.z;
+        this.lastYaw = f;
+        this.lastPitch = f1;
+        // CraftBukkit end
+
         this.teleportRequestTick = this.ticks;
         this.player.updatePositionAndAngles(d0, d1, d2, f, f1);
         this.player.networkHandler.sendPacket(new PlayerPositionLookS2CPacket(d0 - d3, d1 - d4, d2 - d5, f - f2, f1 - f3, set, this.requestedTeleportId));
@@ -881,6 +1228,7 @@
 
     public void onPlayerAction(PlayerActionC2SPacket playeractionc2spacket) {
         NetworkThreadUtils.forceMainThread(playeractionc2spacket, this, this.player.getServerWorld());
+        if (this.player.isFrozen()) return; // CraftBukkit
         BlockPos blockpos = playeractionc2spacket.getPos();
 
         this.player.updateLastActionTime();
@@ -891,14 +1239,48 @@
                 if (!this.player.isSpectator()) {
                     ItemStack itemstack = this.player.getStackInHand(Hand.OFF_HAND);
 
-                    this.player.setStackInHand(Hand.OFF_HAND, this.player.getStackInHand(Hand.MAIN_HAND));
-                    this.player.setStackInHand(Hand.MAIN_HAND, itemstack);
+//                    this.player.setStackInHand(Hand.OFF_HAND, this.player.getStackInHand(Hand.MAIN_HAND));
+//                    this.player.setStackInHand(Hand.MAIN_HAND, itemstack);
+                    // CraftBukkit start - inspiration taken from DispenserRegistry (See SpigotCraft#394)
+                    CraftItemStack mainHand = CraftItemStack.asCraftMirror(itemstack);
+                    CraftItemStack offHand = CraftItemStack.asCraftMirror(this.player.getStackInHand(Hand.MAIN_HAND));
+                    PlayerSwapHandItemsEvent swapItemsEvent = new PlayerSwapHandItemsEvent(getPlayer(), mainHand.clone(), offHand.clone());
+                    Bukkit.getPluginManager().callEvent(swapItemsEvent);
+                    if (swapItemsEvent.isCancelled()) {
+                        return;
+                    }
+                    if (swapItemsEvent.getOffHandItem().equals(offHand)) {
+                        this.player.setStackInHand(Hand.OFF_HAND, this.player.getStackInHand(Hand.MAIN_HAND));
+                    } else {
+                        this.player.setStackInHand(Hand.OFF_HAND, CraftItemStack.asNMSCopy(swapItemsEvent.getOffHandItem()));
+                    }
+                    if (swapItemsEvent.getMainHandItem().equals(mainHand)) {
+                        this.player.setStackInHand(Hand.MAIN_HAND, itemstack);
+                    } else {
+                        this.player.setStackInHand(Hand.MAIN_HAND, CraftItemStack.asNMSCopy(swapItemsEvent.getMainHandItem()));
+                    }
+                    // CraftBukkit end
                     this.player.clearActiveItem();
                 }
 
                 return;
             case DROP_ITEM:
                 if (!this.player.isSpectator()) {
+                    // limit how quickly items can be dropped
+                    // If the ticks aren't the same then the count starts from 0 and we update the lastDropTick.
+                    if (this.lastDropTick != MinecraftServer.currentTick) {
+                        this.dropCount = 0;
+                        this.lastDropTick = MinecraftServer.currentTick;
+                    } else {
+                        // Else we increment the drop count and check the amount.
+                        this.dropCount++;
+                        if (this.dropCount >= 20) {
+                            LOGGER.warn(this.player.getName() + " dropped their items too quickly!");
+                            this.disconnect("You dropped your items too quickly (Hacking?)");
+                            return;
+                        }
+                    }
+                    // CraftBukkit end
                     this.player.dropSelectedItem(false);
                 }
 
@@ -934,6 +1316,7 @@
 
     public void onPlayerInteractBlock(PlayerInteractBlockC2SPacket playerinteractblockc2spacket) {
         NetworkThreadUtils.forceMainThread(playerinteractblockc2spacket, this, this.player.getServerWorld());
+        if (this.player.isFrozen()) return; // CraftBukkit
         ServerWorld serverworld = this.player.getServerWorld();
         Hand hand = playerinteractblockc2spacket.getHand();
         ItemStack itemstack = this.player.getStackInHand(hand);
@@ -944,6 +1327,14 @@
         this.player.updateLastActionTime();
         if (blockpos.getY() < this.server.getWorldHeight()) {
             if (this.requestedTeleportPos == null && this.player.squaredDistanceTo((double) blockpos.getX() + 0.5D, (double) blockpos.getY() + 0.5D, (double) blockpos.getZ() + 0.5D) < 64.0D && serverworld.canPlayerModifyAt(this.player, blockpos)) {
+                // CraftBukkit start - Check if we can actually do something over this large a distance
+                Location eyeLoc = this.getPlayer().getEyeLocation();
+                double reachDistance = NumberConversions.square(eyeLoc.getX() - blockpos.getX()) + NumberConversions.square(eyeLoc.getY() - blockpos.getY()) + NumberConversions.square(eyeLoc.getZ() - blockpos.getZ());
+                if (reachDistance > (this.getPlayer().getGameMode() == org.bukkit.GameMode.CREATIVE ? CREATIVE_PLACE_DISTANCE_SQUARED : SURVIVAL_PLACE_DISTANCE_SQUARED)) {
+                    return;
+                }
+                this.player.clearActiveItem(); // SPIGOT-4706
+                // CraftBukkit end
                 ActionResult actionresult = this.player.interactionManager.interactBlock(this.player, serverworld, itemstack, hand, blockhitresult);
 
                 if (direction == Direction.UP && !actionresult.isAccepted() && blockpos.getY() >= this.server.getWorldHeight() - 1 && canPlace(this.player, itemstack)) {
@@ -966,12 +1357,51 @@
 
     public void onPlayerInteractItem(PlayerInteractItemC2SPacket playerinteractitemc2spacket) {
         NetworkThreadUtils.forceMainThread(playerinteractitemc2spacket, this, this.player.getServerWorld());
+        if (this.player.isFrozen()) return; // CraftBukkit
         ServerWorld serverworld = this.player.getServerWorld();
         Hand hand = playerinteractitemc2spacket.getHand();
         ItemStack itemstack = this.player.getStackInHand(hand);
 
         this.player.updateLastActionTime();
         if (!itemstack.isEmpty()) {
+            // CraftBukkit start
+            // Raytrace to look for 'rogue armswings'
+            float f1 = this.player.pitch;
+            float f2 = this.player.yaw;
+            double d0 = this.player.getX();
+            double d1 = this.player.getY() + (double) this.player.getHeadHeight();
+            double d2 = this.player.getZ();
+            Vec3d vec3d = new Vec3d(d0, d1, d2);
+
+            float f3 = MathHelper.cos(-f2 * 0.017453292F - 3.1415927F);
+            float f4 = MathHelper.sin(-f2 * 0.017453292F - 3.1415927F);
+            float f5 = -MathHelper.cos(-f1 * 0.017453292F);
+            float f6 = MathHelper.sin(-f1 * 0.017453292F);
+            float f7 = f4 * f5;
+            float f8 = f3 * f5;
+            double d3 = player.interactionManager.getGameMode()== GameMode.CREATIVE ? 5.0D : 4.5D;
+            Vec3d vec3d1 = vec3d.add((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
+            HitResult movingobjectposition = this.player.world.rayTrace(new RayTraceContext(vec3d, vec3d1, RayTraceContext.ShapeType.OUTLINE, RayTraceContext.FluidHandling.NONE, player));
+
+            boolean cancelled;
+            if (movingobjectposition == null || movingobjectposition.getType() != HitResult.Type.BLOCK) {
+                org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.player, Action.RIGHT_CLICK_AIR, itemstack, hand);
+                cancelled = event.useItemInHand() == Event.Result.DENY;
+            } else {
+                if (player.interactionManager.firedInteract) {
+                    player.interactionManager.firedInteract = false;
+                    cancelled = player.interactionManager.interactResult;
+                } else {
+                    BlockHitResult movingobjectpositionblock = (BlockHitResult) movingobjectposition;
+                    org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(player, Action.RIGHT_CLICK_BLOCK, movingobjectpositionblock.getBlockPosition(), movingobjectpositionblock.getDirection(), itemstack, true, enumhand);
+                    cancelled = event.useItemInHand() == Event.Result.DENY;
+                }
+            }
+
+            if (cancelled) {
+                this.player.getBukkitEntity().updateInventory(); // SPIGOT-2524
+                return;
+            }
             ActionResult actionresult = this.player.interactionManager.interactItem(this.player, serverworld, itemstack, hand);
 
             if (actionresult.shouldSwingHand()) {
@@ -991,7 +1421,7 @@
                 Entity entity = spectatorteleportc2spacket.getTarget(serverworld);
 
                 if (entity != null) {
-                    this.player.teleport(serverworld, entity.getX(), entity.getY(), entity.getZ(), entity.yaw, entity.pitch);
+                    this.player.teleport(serverworld, entity.getX(), entity.getY(), entity.getZ(), entity.yaw, entity.pitch, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.SPECTATE); // CraftBukkit
                     return;
                 }
             }
@@ -999,7 +1429,10 @@
 
     }
 
-    public void onResourcePackStatus(ResourcePackStatusC2SPacket resourcepackstatusc2spacket) {}
+    public void onResourcePackStatus(ResourcePackStatusC2SPacket resourcepackstatusc2spacket) {
+        NetworkThreadUtils.forceMainThread(resourcepackstatusc2spacket, this, this.player.getServerWorld());
+        Bukkit.getPluginManager().callEvent(new PlayerResourcePackStatusEvent(getPlayer(), PlayerResourcePackStatusEvent.Status.values()[resourcepackstatusc2spacket.getStatus().ordinal()]));
+    }
 
     public void onBoatPaddleState(BoatPaddleStateC2SPacket boatpaddlestatec2spacket) {
         NetworkThreadUtils.forceMainThread(boatpaddlestatec2spacket, this, this.player.getServerWorld());
@@ -1012,11 +1445,26 @@
     }
 
     public void onDisconnected(Text text) {
+        // CraftBukkit start - Rarely it would send a disconnect line twice
+        if (this.processedDisconnect) {
+            return;
+        } else {
+            this.processedDisconnect = true;
+        }
+        // CraftBukkit end
         ServerPlayNetworkHandler.LOGGER.info("{} lost connection: {}", (Object) this.player.getName().getString(), (Object) text.getString());
+        // CraftBukkit start - Replace vanilla quit message handling with our own.
+        /*
         this.server.forcePlayerSampleUpdate();
         this.server.getPlayerManager().broadcastChatMessage((new TranslatableText("multiplayer.player.left", new Object[]{this.player.getDisplayName()})).formatted(Formatting.YELLOW), MessageType.SYSTEM, Util.NIL_UUID);
+        */
+
         this.player.onDisconnect();
-        this.server.getPlayerManager().remove(this.player);
+        String quitMessage = this.server.getPlayerManager().remove(this.player);
+        if ((quitMessage != null) && (quitMessage.length() > 0)) {
+            this.server.getPlayerManager().broadcastChatMessage(CraftChatMessage.fromString(quitMessage));
+        }
+        // CraftBukkit end
         if (this.isHost()) {
             ServerPlayNetworkHandler.LOGGER.info("Stopping singleplayer server as player logged out");
             this.server.stop(false);
@@ -1042,6 +1490,15 @@
             }
         }
 
+        // CraftBukkit start
+        if (packet == null) {
+            return;
+        } else if (packet instanceof PlayerSpawnPositionS2CPacket) {
+            PlayerSpawnPositionS2CPacket packet6 = (PlayerSpawnPositionS2CPacket) packet;
+            this.player.compassTarget = new Location(this.getPlayer().getWorld(), packet6.getPos().getX(), packet6.getPos().getY(), packet6.getPos().getZ());
+        }
+        // CraftBukkit end
+
         try {
             this.connection.send(packet, genericfuturelistener);
         } catch (Throwable throwable) {
@@ -1057,7 +1514,16 @@
 
     public void onUpdateSelectedSlot(UpdateSelectedSlotC2SPacket updateselectedslotc2spacket) {
         NetworkThreadUtils.forceMainThread(updateselectedslotc2spacket, this, this.player.getServerWorld());
+        if (this.player.isFrozen()) return; // CraftBukkit
         if (updateselectedslotc2spacket.getSelectedSlot() >= 0 && updateselectedslotc2spacket.getSelectedSlot() < PlayerInventory.getHotbarSize()) {
+            PlayerItemHeldEvent event = new PlayerItemHeldEvent(this.getPlayer(), this.player.inventory.selectedSlot, updateselectedslotc2spacket.getSelectedSlot());
+            Bukkit.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                this.sendPacket(new HeldItemChangeS2CPacket(this.player.inventory.selectedSlot));
+                this.player.updateLastActionTime();
+                return;
+            }
+            // CraftBukkit end
             if (this.player.inventory.selectedSlot != updateselectedslotc2spacket.getSelectedSlot() && this.player.getActiveHand() == Hand.MAIN_HAND) {
                 this.player.clearActiveItem();
             }
@@ -1066,12 +1532,23 @@
             this.player.updateLastActionTime();
         } else {
             ServerPlayNetworkHandler.LOGGER.warn("{} tried to set an invalid carried item", (Object) this.player.getName().getString());
+            this.disconnect("Invalid hotbar selection (Hacking?)"); // CraftBukkit
         }
     }
 
     public void onGameMessage(ChatMessageC2SPacket chatmessagec2spacket) {
-        NetworkThreadUtils.forceMainThread(chatmessagec2spacket, this, this.player.getServerWorld());
-        if (this.player.getClientChatVisibility() == ChatVisibility.HIDDEN) {
+        // CraftBukkit start - async chat
+        // SPIGOT-3638
+        if (this.server.isStopped()) {
+            return;
+        }
+
+        boolean isSync = chatmessagec2spacket.getChatMessage().startsWith("/");
+        if (chatmessagec2spacket.getChatMessage().startsWith("/")) {
+            NetworkThreadUtils.forceMainThread(chatmessagec2spacket, this, this.player.getServerWorld());
+        }
+        // CraftBukkit end
+        if (this.player.isDead() || this.player.getClientChatVisibility() == ChatVisibility.HIDDEN) { // CraftBukkit - dead men tell no tales
             this.sendPacket(new GameMessageS2CPacket((new TranslatableText("chat.cannotSend")).formatted(Formatting.RED), MessageType.SYSTEM, Util.NIL_UUID));
         } else {
             this.player.updateLastActionTime();
@@ -1079,39 +1556,251 @@
 
             for (int i = 0; i < s.length(); ++i) {
                 if (!SharedConstants.isValidChar(s.charAt(i))) {
-                    this.disconnect(new TranslatableText("multiplayer.disconnect.illegal_characters"));
+                    // CraftBukkit start - threadsafety
+                    if (!isSync) {
+                        Waitable waitable = new Waitable() {
+                            @Override
+                            protected Object evaluate() {
+                                ServerPlayNetworkHandler.this.disconnect(new TranslatableText("multiplayer.disconnect.illegal_characters"));
+                                return null;
+                            }
+                        };
+
+                        this.server.processQueue.add(waitable);
+
+                        try {
+                            waitable.get();
+                        } catch (InterruptedException e) {
+                            Thread.currentThread().interrupt();
+                        } catch (ExecutionException e) {
+                            throw new RuntimeException(e);
+                        }
+                    } else {
+                        this.disconnect(new TranslatableText("multiplayer.disconnect.illegal_characters"));
+                    }
+                    // CraftBukkit end
                     return;
                 }
             }
 
-            if (s.startsWith("/")) {
-                this.executeCommand(s);
+            // CraftBukkit start
+            if (isSync) {
+                try {
+                    this.craftServer.playerCommandState = true;
+                    this.executeCommand(s);
+                } finally {
+                    this.craftServer.playerCommandState = false;
+                }
+            } else if (s.isEmpty()) {
+                LOGGER.warn(this.player.getName() + " tried to send an empty message");
+            } else if (getPlayer().isConversing()) {
+                final String conversationInput = s;
+                this.server.processQueue.add(new Runnable() {
+                    @Override
+                    public void run() {
+                        getPlayer().acceptConversationInput(conversationInput);
+                    }
+                });
+            } else if (this.player.getClientChatVisibility() == ChatVisibility.SYSTEM) { // Re-add "Command Only" flag check
+                this.sendPacket(new GameMessageS2CPacket((new TranslatableText("chat.cannotSend")).a(Formatting.RED), MessageType.SYSTEM, Util.NIL_UUID));
+            } else if (true) {
+                this.chat(s, true);
+                // CraftBukkit end - the below is for reference. :)
             } else {
                 TranslatableText translatabletext = new TranslatableText("chat.type.text", new Object[]{this.player.getDisplayName(), s});
 
                 this.server.getPlayerManager().broadcastChatMessage(translatabletext, MessageType.CHAT, this.player.getUuid());
             }
 
-            this.messageCooldown += 20;
-            if (this.messageCooldown > 200 && !this.server.getPlayerManager().isOperator(this.player.getGameProfile())) {
-                this.disconnect(new TranslatableText("disconnect.spam"));
+            // CraftBukkit start - replaced with thread safe throttle
+            // this.messageCooldown += 20;
+            if (chatSpamField.addAndGet(this, 20) > 200 && !this.server.getPlayerManager().isOperator(this.player.getGameProfile())) {
+                if (!isSync) {
+                    Waitable waitable = new Waitable() {
+                        @Override
+                        protected Object evaluate() {
+                            ServerPlayNetworkHandler.this.disconnect(new TranslatableText("disconnect.spam"));
+                            return null;
+                        }
+                    };
+
+                    this.server.processQueue.add(waitable);
+
+                    try {
+                        waitable.get();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    } catch (ExecutionException e) {
+                        throw new RuntimeException(e);
+                    }
+                } else {
+                    this.disconnect(new TranslatableText("disconnect.spam"));
+                }
+                // CraftBukkit end
             }
+        }
+    }
+
+    // CraftBukkit start - add method
+    public void chat(String s, boolean async) {
+        if (s.isEmpty() || this.player.getClientChatVisibility() == ChatVisibility.HIDDEN) {
+            return;
+        }
+
+        if (!async && s.startsWith("/")) {
+            this.executeCommand(s);
+        } else if (this.player.getClientChatVisibility() == ChatVisibility.SYSTEM) {
+            // Do nothing, this is coming from a plugin
+        } else {
+            Player player = this.getPlayer();
+            AsyncPlayerChatEvent event = new AsyncPlayerChatEvent(async, player, s, new LazyPlayerSet(server));
+            Bukkit.getPluginManager().callEvent(event);
+
+            if (PlayerChatEvent.getHandlerList().getRegisteredListeners().length != 0) {
+                // Evil plugins still listening to deprecated event
+                final PlayerChatEvent queueEvent = new PlayerChatEvent(player, event.getMessage(), event.getFormat(), event.getRecipients());
+                queueEvent.setCancelled(event.isCancelled());
+                Waitable waitable = new Waitable() {
+                    @Override
+                    protected Object evaluate() {
+                        org.bukkit.Bukkit.getPluginManager().callEvent(queueEvent);
+
+                        if (queueEvent.isCancelled()) {
+                            return null;
+                        }
 
+                        String message = String.format(queueEvent.getFormat(), queueEvent.getPlayer().getDisplayName(), queueEvent.getMessage());
+                        ServerPlayNetworkHandler.this.server.console.sendMessage(message);
+                        if (((LazyPlayerSet) queueEvent.getRecipients()).isLazy()) {
+                            for (Object player : ServerPlayNetworkHandler.this.server.getPlayerManager().getPlayerList()) {
+                                ((ServerPlayerEntity) player).sendMessage(CraftChatMessage.fromString(message));
+                            }
+                        } else {
+                            for (Player player : queueEvent.getRecipients()) {
+                                player.sendMessage(message);
+                            }
+                        }
+                        return null;
+                    }};
+                if (async) {
+                    server.processQueue.add(waitable);
+                } else {
+                    waitable.run();
+                }
+                try {
+                    waitable.get();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt(); // This is proper habit for java. If we aren't handling it, pass it on!
+                } catch (ExecutionException e) {
+                    throw new RuntimeException("Exception processing chat event", e.getCause());
+                }
+            } else {
+                if (event.isCancelled()) {
+                    return;
+                }
+
+                s = String.format(event.getFormat(), event.getPlayer().getDisplayName(), event.getMessage());
+                server.console.sendMessage(s);
+                if (((LazyPlayerSet) event.getRecipients()).isLazy()) {
+                    for (Object recipient : server.getPlayerManager().getPlayerList()) {
+                        ((ServerPlayerEntity) recipient).sendMessage(CraftChatMessage.fromString(s));
+                    }
+                } else {
+                    for (Player recipient : event.getRecipients()) {
+                        recipient.sendMessage(s);
+                    }
+                }
+            }
         }
     }
+    // CraftBukkit end
 
     private void executeCommand(String s) {
-        this.server.getCommandManager().execute(this.player.getCommandSource(), s);
+        // CraftBukkit start - whole method
+        this.LOGGER.info(this.player.getName() + " issued server command: " + s);
+
+        CraftPlayer player = this.getPlayer();
+
+        PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(player, s, new LazyPlayerSet(server));
+        Bukkit.getPluginManager().callEvent(event);
+
+        if (event.isCancelled()) {
+            return;
+        }
+
+        try {
+            if (this.craftServer.dispatchCommand(event.getPlayer(), event.getMessage().substring(1))) {
+                return;
+            }
+        } catch (org.bukkit.command.CommandException ex) {
+            player.sendMessage(org.bukkit.ChatColor.RED + "An internal error occurred while attempting to perform this command");
+            java.util.logging.Logger.getLogger(ServerPlayNetworkHandler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
+            return;
+        }
+        // this.server.getCommandManager().execute(this.player.getCommandSource(), s);
+        // CraftBukkit end
     }
 
     public void onHandSwing(HandSwingC2SPacket handswingc2spacket) {
         NetworkThreadUtils.forceMainThread(handswingc2spacket, this, this.player.getServerWorld());
+        if (this.player.isFrozen()) return; // CraftBukkit
         this.player.updateLastActionTime();
+        // CraftBukkit start - Raytrace to look for 'rogue armswings'
+        float f1 = this.player.pitch;
+        float f2 = this.player.yaw;
+        double d0 = this.player.getX();
+        double d1 = this.player.getY() + (double) this.player.getEyeY();
+        double d2 = this.player.getZ();
+        Vec3d vec3d = new Vec3d(d0, d1, d2);
+
+        float f3 = MathHelper.cos(-f2 * 0.017453292F - 3.1415927F);
+        float f4 = MathHelper.sin(-f2 * 0.017453292F - 3.1415927F);
+        float f5 = -MathHelper.cos(-f1 * 0.017453292F);
+        float f6 = MathHelper.sin(-f1 * 0.017453292F);
+        float f7 = f4 * f5;
+        float f8 = f3 * f5;
+        double d3 = player.interactionManager.getGameMode()== GameMode.CREATIVE ? 5.0D : 4.5D;
+        Vec3d vec3d1 = vec3d.add((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
+        HitResult movingobjectposition = this.player.world.rayTrace(new RayTraceContext(vec3d, vec3d1, RayTraceContext.ShapeType.OUTLINE, RayTraceContext.FluidHandling.NONE, player));
+
+        if (movingobjectposition == null || movingobjectposition.getType() != HitResult.Type.BLOCK) {
+            CraftEventFactory.callPlayerInteractEvent(this.player, Action.LEFT_CLICK_AIR, this.player.inventory.getMainHandStack(), Hand.MAIN_HAND);
+        }
+
+        // Arm swing animation
+        PlayerAnimationEvent event = new PlayerAnimationEvent(this.getPlayer());
+        Bukkit.getPluginManager().callEvent(event);
+
+        if (event.isCancelled()) return;
+        // CraftBukkit end
         this.player.swingHand(handswingc2spacket.getHand());
     }
 
     public void onClientCommand(ClientCommandC2SPacket clientcommandc2spacket) {
         NetworkThreadUtils.forceMainThread(clientcommandc2spacket, this, this.player.getServerWorld());
+        // CraftBukkit start
+        if (this.player.isDead()) return;
+        switch (clientcommandc2spacket.getMode()) {
+            case PRESS_SHIFT_KEY:
+            case RELEASE_SHIFT_KEY:
+                PlayerToggleSneakEvent event = new PlayerToggleSneakEvent(this.getPlayer(), clientcommandc2spacket.getMode() == ClientCommandC2SPacket.Mode.PRESS_SHIFT_KEY);
+                Bukkit.getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    return;
+                }
+                break;
+            case START_SPRINTING:
+            case STOP_SPRINTING:
+                PlayerToggleSprintEvent e2 = new PlayerToggleSprintEvent(this.getPlayer(), clientcommandc2spacket.getMode() == ClientCommandC2SPacket.Mode.START_SPRINTING);
+                Bukkit.getPluginManager().callEvent(e2);
+
+                if (e2.isCancelled()) {
+                    return;
+                }
+                break;
+        }
+        // CraftBukkit end
         this.player.updateLastActionTime();
         JumpingMount jumpingmount;
 
@@ -1168,6 +1857,7 @@
 
     public void onPlayerInteractEntity(PlayerInteractEntityC2SPacket playerinteractentityc2spacket) {
         NetworkThreadUtils.forceMainThread(playerinteractentityc2spacket, this, this.player.getServerWorld());
+        if (this.player.isFrozen()) return; // CraftBukkit
         ServerWorld serverworld = this.player.getServerWorld();
         Entity entity = playerinteractentityc2spacket.getEntity(serverworld);
 
@@ -1180,18 +1870,72 @@
                 Hand hand = playerinteractentityc2spacket.getHand();
                 Optional<ActionResult> optional = Optional.empty();
 
+                ItemStack itemInHand = this.player.getStackInHand(playerinteractentityc2spacket.getHand() == null ? Hand.MAIN_HAND : playerinteractentityc2spacket.getHand()); // CraftBukkit
+
+                if (playerinteractentityc2spacket.getType() == PlayerInteractEntityC2SPacket.InteractionType.INTERACT
+                        || playerinteractentityc2spacket.getType() == PlayerInteractEntityC2SPacket.InteractionType.INTERACT_AT) {
+                    // CraftBukkit start
+                    boolean triggerLeashUpdate = itemInHand != null && itemInHand.getItem() == Items.LEAD && entity instanceof MobEntity;
+                    Item origItem = this.player.inventory.getMainHandStack() == null ? null : this.player.inventory.getMainHandStack().getItem();
+                    PlayerInteractEntityEvent event;
+                    if (playerinteractentityc2spacket.getType() == PlayerInteractEntityC2SPacket.InteractionType.INTERACT) {
+                        event = new PlayerInteractEntityEvent((Player) this.getPlayer(), entity.getBukkitEntity(), (playerinteractentityc2spacket.getHand() == Hand.OFF_HAND) ? EquipmentSlot.OFF_HAND : EquipmentSlot.HAND);
+                    } else {
+                        Vec3d target = playerinteractentityc2spacket.getHitPosition();
+                        event = new PlayerInteractAtEntityEvent((Player) this.getPlayer(), entity.getBukkitEntity(), new org.bukkit.util.Vector(target.x, target.y, target.z), (playerinteractentityc2spacket.getHand() == Hand.OFF_HAND) ? EquipmentSlot.OFF_HAND : EquipmentSlot.HAND);
+                    }
+                    Bukkit.getPluginManager().callEvent(event);
+
+                    // Fish bucket - SPIGOT-4048
+                    if ((entity instanceof FishEntity && origItem != null && origItem.asItem() == Items.WATER_BUCKET) && (event.isCancelled() || this.player.inventory.getMainHandStack() == null || this.player.inventory.getMainHandStack().getItem() != origItem)) {
+                        this.sendPacket(new MobSpawnS2CPacket((FishEntity) entity));
+                        this.player.openHandledScreen(this.player.currentScreenHandler);
+                    }
+
+                    if (triggerLeashUpdate && (event.isCancelled() || this.player.inventory.getMainHandStack() == null || this.player.inventory.getMainHandStack().getItem() != origItem)) {
+                        // Refresh the current leash state
+                        this.sendPacket(new EntityAttachS2CPacket(entity, ((MobEntity) entity).getHoldingEntity()));
+                    }
+
+                    if (event.isCancelled() || this.player.inventory.getMainHandStack() == null || this.player.inventory.getMainHandStack().getItem() != origItem) {
+                        // Refresh the current entity metadata
+                        this.sendPacket(new EntityTrackerUpdateS2CPacket(entity.getEntityId(), entity.getDataTracker(), true));
+                    }
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
+                    // CraftBukkit end
+                }
+
                 if (playerinteractentityc2spacket.getType() == PlayerInteractEntityC2SPacket.InteractionType.INTERACT) {
                     optional = Optional.of(this.player.interact(entity, hand));
+                    // CraftBukkit start
+                    if (!itemInHand.isEmpty() && itemInHand.getCount() <= -1) {
+                        this.player.openHandledScreen(this.player.currentScreenHandler);
+                    }
+                    // CraftBukkit end
                 } else if (playerinteractentityc2spacket.getType() == PlayerInteractEntityC2SPacket.InteractionType.INTERACT_AT) {
                     optional = Optional.of(entity.interactAt(this.player, playerinteractentityc2spacket.getHitPosition(), hand));
+                    // CraftBukkit start
+                    if (!itemInHand.isEmpty() && itemInHand.getCount() <= -1) {
+                        this.player.openHandledScreen(this.player.currentScreenHandler);
+                    }
+                    // CraftBukkit end
                 } else if (playerinteractentityc2spacket.getType() == PlayerInteractEntityC2SPacket.InteractionType.ATTACK) {
-                    if (entity instanceof ItemEntity || entity instanceof ExperienceOrbEntity || entity instanceof PersistentProjectileEntity || entity == this.player) {
+                    if (entity instanceof ItemEntity || entity instanceof ExperienceOrbEntity || entity instanceof PersistentProjectileEntity || (entity == this.player && !player.isSpectator())) { // CraftBukkit
                         this.disconnect(new TranslatableText("multiplayer.disconnect.invalid_entity_attacked"));
                         ServerPlayNetworkHandler.LOGGER.warn("Player {} tried to attack an invalid entity", (Object) this.player.getName().getString());
                         return;
                     }
 
                     this.player.attack(entity);
+
+                    // CraftBukkit start
+                    if (!itemInHand.isEmpty() && itemInHand.getCount() <= -1) {
+                        this.player.openHandledScreen(this.player.currentScreenHandler);
+                    }
+                    // CraftBukkit end
                 }
 
                 if (optional.isPresent() && ((ActionResult) optional.get()).isAccepted()) {
@@ -1236,14 +1980,18 @@
 
     public void onGuiClose(GuiCloseC2SPacket guiclosec2spacket) {
         NetworkThreadUtils.forceMainThread(guiclosec2spacket, this, this.player.getServerWorld());
+        if (this.player.isFrozen()) return; // CraftBukkit
+        CraftEventFactory.handleInventoryCloseEvent(this.player); // CraftBukkit
         this.player.closeCurrentScreen();
     }
 
     public void onClickWindow(ClickWindowC2SPacket clickwindowc2spacket) {
         NetworkThreadUtils.forceMainThread(clickwindowc2spacket, this, this.player.getServerWorld());
+        if (this.player.isFrozen()) return; // CraftBukkit
         this.player.updateLastActionTime();
-        if (this.player.currentScreenHandler.syncId == clickwindowc2spacket.getSyncId() && this.player.currentScreenHandler.isNotRestricted(this.player)) {
-            if (this.player.isSpectator()) {
+        if (this.player.currentScreenHandler.syncId == clickwindowc2spacket.getSyncId() && this.player.currentScreenHandler.isNotRestricted(this.player)&& this.player.currentScreenHandler.canUse(this.player)) { // CraftBukkit
+            boolean cancelled = this.player.isSpectator(); // CraftBukkit - see below if
+            if (false /*this.player.isSpectator()*/) {
                 DefaultedList<ItemStack> defaultedlist = DefaultedList.of();
 
                 for (int i = 0; i < this.player.currentScreenHandler.slots.size(); ++i) {
@@ -1252,8 +2000,276 @@
 
                 this.player.onHandlerRegistered(this.player.currentScreenHandler, defaultedlist);
             } else {
-                ItemStack itemstack = this.player.currentScreenHandler.onSlotClick(clickwindowc2spacket.getSlot(), clickwindowc2spacket.getClickData(), clickwindowc2spacket.getActionType(), this.player);
+//                ItemStack itemstack = this.player.currentScreenHandler.onSlotClick(clickwindowc2spacket.getSlot(), clickwindowc2spacket.getClickData(), clickwindowc2spacket.getActionType(), this.player);
+
+                // CraftBukkit start - Call InventoryClickEvent
+                if (clickwindowc2spacket.getSlot() < -1 && clickwindowc2spacket.getSlot() != -999) {
+                    return;
+                }
+
+                InventoryView inventory = this.player.currentScreenHandler.getBukkitView();
+                SlotType type = inventory.getSlotType(clickwindowc2spacket.getSlot());
+
+                InventoryClickEvent event;
+                ClickType click = ClickType.UNKNOWN;
+                InventoryAction action = InventoryAction.UNKNOWN;
+
+                ItemStack itemstack = ItemStack.EMPTY;
+
+                switch (clickwindowc2spacket.getActionType()) {
+                    case PICKUP:
+                        if (clickwindowc2spacket.getClickData() == 0) {
+                            click = ClickType.LEFT;
+                        } else if (clickwindowc2spacket.getClickData() == 1) {
+                            click = ClickType.RIGHT;
+                        }
+                        if (clickwindowc2spacket.getClickData() == 0 || clickwindowc2spacket.getClickData() == 1) {
+                            action = InventoryAction.NOTHING; // Don't want to repeat ourselves
+                            if (clickwindowc2spacket.getSlot() == -999) {
+                                if (!player.inventory.getCursorStack().isEmpty()) {
+                                    action = clickwindowc2spacket.getClickData() == 0 ? InventoryAction.DROP_ALL_CURSOR : InventoryAction.DROP_ONE_CURSOR;
+                                }
+                            } else if (clickwindowc2spacket.getSlot() < 0)  {
+                                action = InventoryAction.NOTHING;
+                            } else {
+                                Slot slot = this.player.currentScreenHandler.getSlot(clickwindowc2spacket.getSlot());
+                                if (slot != null) {
+                                    ItemStack clickedItem = slot.getStack();
+                                    ItemStack cursor = player.inventory.getCursorStack();
+                                    if (clickedItem.isEmpty()) {
+                                        if (!cursor.isEmpty()) {
+                                            action = clickwindowc2spacket.getClickData() == 0 ? InventoryAction.PLACE_ALL : InventoryAction.PLACE_ONE;
+                                        }
+                                    } else if (slot.canTakeItems(player)) {
+                                        if (cursor.isEmpty()) {
+                                            action = clickwindowc2spacket.getClickData() == 0 ? InventoryAction.PICKUP_ALL : InventoryAction.PICKUP_HALF;
+                                        } else if (slot.canInsert(cursor)) {
+                                            if (clickedItem.isItemEqual(cursor) && ItemStack.areEqual(clickedItem, cursor)) {
+                                                int toPlace = clickwindowc2spacket.getClickData() == 0 ? cursor.getCount() : 1;
+                                                toPlace = Math.min(toPlace, clickedItem.getMaxCount() - clickedItem.getCount());
+                                                toPlace = Math.min(toPlace, slot.inventory.getMaxCountPerStack() - clickedItem.getCount());
+                                                if (toPlace == 1) {
+                                                    action = InventoryAction.PLACE_ONE;
+                                                } else if (toPlace == cursor.getCount()) {
+                                                    action = InventoryAction.PLACE_ALL;
+                                                } else if (toPlace < 0) {
+                                                    action = toPlace != -1 ? InventoryAction.PICKUP_SOME : InventoryAction.PICKUP_ONE; // this happens with oversized stacks
+                                                } else if (toPlace != 0) {
+                                                    action = InventoryAction.PLACE_SOME;
+                                                }
+                                            } else if (cursor.getCount() <= slot.getMaxStackAmount()) {
+                                                action = InventoryAction.SWAP_WITH_CURSOR;
+                                            }
+                                        } else if (cursor.getItem() == clickedItem.getItem() && ItemStack.areEqual(cursor, clickedItem)) {
+                                            if (clickedItem.getCount() >= 0) {
+                                                if (clickedItem.getCount() + cursor.getCount() <= cursor.getMaxCount()) {
+                                                    // As of 1.5, this is result slots only
+                                                    action = InventoryAction.PICKUP_ALL;
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        break;
+                    // TODO check on updates
+                    case QUICK_MOVE:
+                        if (clickwindowc2spacket.getClickData() == 0) {
+                            click = ClickType.SHIFT_LEFT;
+                        } else if (clickwindowc2spacket.getClickData() == 1) {
+                            click = ClickType.SHIFT_RIGHT;
+                        }
+                        if (clickwindowc2spacket.getClickData() == 0 || clickwindowc2spacket.getClickData() == 1) {
+                            if (clickwindowc2spacket.getSlot() < 0) {
+                                action = InventoryAction.NOTHING;
+                            } else {
+                                Slot slot = this.player.currentScreenHandler.getSlot(clickwindowc2spacket.getSlot());
+                                if (slot != null && slot.canTakeItems(this.player) && slot.hasStack()) {
+                                    action = InventoryAction.MOVE_TO_OTHER_INVENTORY;
+                                } else {
+                                    action = InventoryAction.NOTHING;
+                                }
+                            }
+                        }
+                        break;
+                    case SWAP:
+                        if (clickwindowc2spacket.getClickData() >= 0 && clickwindowc2spacket.getClickData() < 9) {
+                            click = ClickType.NUMBER_KEY;
+                            Slot clickedSlot = this.player.currentScreenHandler.getSlot(clickwindowc2spacket.getSlot());
+                            if (clickedSlot.canTakeItems(player)) {
+                                ItemStack hotbar = this.player.inventory.getStack(clickwindowc2spacket.getClickData());
+                                boolean canCleanSwap = hotbar.isEmpty() || (clickedSlot.inventory == player.inventory && clickedSlot.canInsert(hotbar)); // the slot will accept the hotbar item
+                                if (clickedSlot.hasStack()) {
+                                    if (canCleanSwap) {
+                                        action = InventoryAction.HOTBAR_SWAP;
+                                    } else {
+                                        action = InventoryAction.HOTBAR_MOVE_AND_READD;
+                                    }
+                                } else if (!clickedSlot.hasStack() && !hotbar.isEmpty() && clickedSlot.canInsert(hotbar)) {
+                                    action = InventoryAction.HOTBAR_SWAP;
+                                } else {
+                                    action = InventoryAction.NOTHING;
+                                }
+                            } else {
+                                action = InventoryAction.NOTHING;
+                            }
+                        }
+                        break;
+                    case CLONE:
+                        if (clickwindowc2spacket.getClickData() == 2) {
+                            click = ClickType.MIDDLE;
+                            if (clickwindowc2spacket.getSlot() < 0) {
+                                action = InventoryAction.NOTHING;
+                            } else {
+                                Slot slot = this.player.currentScreenHandler.getSlot(clickwindowc2spacket.getSlot());
+                                if (slot != null && slot.getStack() && player.abilities.canInstantlyBuild && player.inventory.getCursorStack().isEmpty()) {
+                                    action = InventoryAction.CLONE_STACK;
+                                } else {
+                                    action = InventoryAction.NOTHING;
+                                }
+                            }
+                        } else {
+                            click = ClickType.UNKNOWN;
+                            action = InventoryAction.UNKNOWN;
+                        }
+                        break;
+                    case THROW:
+                        if (clickwindowc2spacket.getSlot() >= 0) {
+                            if (clickwindowc2spacket.getClickData() == 0) {
+                                click = ClickType.DROP;
+                                Slot slot = this.player.currentScreenHandler.getSlot(clickwindowc2spacket.getSlot());
+                                if (slot != null && slot.hasStack() && slot.canTakeItems(player) && !slot.getStack().isEmpty() && slot.getStack().getItem() != Item.BLOCK_ITEMS.getOrDefault(Blocks.AIR, Items.AIR)) {
+                                    action = InventoryAction.DROP_ONE_SLOT;
+                                } else {
+                                    action = InventoryAction.NOTHING;
+                                }
+                            } else if (clickwindowc2spacket.getClickData() == 1) {
+                                click = ClickType.CONTROL_DROP;
+                                Slot slot = this.player.currentScreenHandler.getSlot(clickwindowc2spacket.getSlot());
+                                if (slot != null && slot.hasStack() && slot.canTakeItems(player) && !slot.getStack().isEmpty() && slot.getStack().getItem() != Item.BLOCK_ITEMS.getOrDefault(Blocks.AIR, Items.AIR)) {
+                                    action = InventoryAction.DROP_ALL_SLOT;
+                                } else {
+                                    action = InventoryAction.NOTHING;
+                                }
+                            }
+                        } else {
+                            // Sane default (because this happens when they are holding nothing. Don't ask why.)
+                            click = ClickType.LEFT;
+                            if (clickwindowc2spacket.getClickData() == 1) {
+                                click = ClickType.RIGHT;
+                            }
+                            action = InventoryAction.NOTHING;
+                        }
+                        break;
+                    case QUICK_CRAFT:
+                        itemstack = this.player.currentScreenHandler.onSlotClick(clickwindowc2spacket.getSlot(), clickwindowc2spacket.getClickData(), clickwindowc2spacket.getActionType(), this.player);
+                        break;
+                    case PICKUP_ALL:
+                        click = ClickType.DOUBLE_CLICK;
+                        action = InventoryAction.NOTHING;
+                        if (clickwindowc2spacket.getSlot() >= 0 && !this.player.inventory.getCursorStack().isEmpty()) {
+                            ItemStack cursor = this.player.inventory.getCursorStack();
+                            action = InventoryAction.NOTHING;
+                            // Quick check for if we have any of the item
+                            if (inventory.getTopInventory().contains(CraftMagicNumbers.getMaterial(cursor.getItem())) || inventory.getBottomInventory().contains(CraftMagicNumbers.getMaterial(cursor.getItem()))) {
+                                action = InventoryAction.COLLECT_TO_CURSOR;
+                            }
+                        }
+                        break;
+                    default:
+                        break;
+                }
+
+                if (clickwindowc2spacket.getActionType() != SlotActionType.QUICK_CRAFT) {
+                    if (click == ClickType.NUMBER_KEY) {
+                        event = new InventoryClickEvent(inventory, type, clickwindowc2spacket.getSlot(), click, action, clickwindowc2spacket.getClickData());
+                    } else {
+                        event = new InventoryClickEvent(inventory, type, clickwindowc2spacket.getSlot(), click, action);
+                    }
+
+                    org.bukkit.inventory.Inventory top = inventory.getTopInventory();
+                    if (clickwindowc2spacket.getSlot() == 0 && top instanceof CraftingInventory) {
+                        org.bukkit.inventory.Recipe recipe = ((CraftingInventory) top).getRecipe();
+                        if (recipe != null) {
+                            if (click == ClickType.NUMBER_KEY) {
+                                event = new CraftItemEvent(recipe, inventory, type, clickwindowc2spacket.getSlot(), click, action, clickwindowc2spacket.getClickData());
+                            } else {
+                                event = new CraftItemEvent(recipe, inventory, type, clickwindowc2spacket.getSlot(), click, action);
+                            }
+                        }
+                    }
+
+                    event.setCancelled(cancelled);
+                    ScreenHandler oldContainer = this.player.currentScreenHandler; // SPIGOT-1224
+                    Bukkit.getPluginManager().callEvent(event);
+                    if (this.player.currentScreenHandler != oldContainer) {
+                        return;
+                    }
+                    switch (event.getResult()) {
+                        case ALLOW:
+                        case DEFAULT:
+                            itemstack = this.player.currentScreenHandler.onSlotClick(clickwindowc2spacket.getSlot(), clickwindowc2spacket.getClickData(), clickwindowc2spacket.getActionType(), this.player);
+                            break;
+                        case DENY:
+                            /* Needs enum constructor in InventoryAction
+                            if (action.modifiesOtherSlots()) {
 
+                            } else {
+                                if (action.modifiesCursor()) {
+                                    this.player.playerConnection.sendPacket(new Packet103SetSlot(-1, -1, this.player.inventory.getCursorStack()));
+                                }
+                                if (action.modifiesClicked()) {
+                                    this.player.playerConnection.sendPacket(new Packet103SetSlot(this.player.currentScreenHandler.windowId, packet102windowclick.slot, this.player.currentScreenHandler.getSlot(packet102windowclick.slot).getItem()));
+                                }
+                            }*/
+                            switch (action) {
+                                // Modified other slots
+                                case PICKUP_ALL:
+                                case MOVE_TO_OTHER_INVENTORY:
+                                case HOTBAR_MOVE_AND_READD:
+                                case HOTBAR_SWAP:
+                                case COLLECT_TO_CURSOR:
+                                case UNKNOWN:
+                                    this.player.openHandledScreen(this.player.currentScreenHandler);
+                                    break;
+                                // Modified cursor and clicked
+                                case PICKUP_SOME:
+                                case PICKUP_HALF:
+                                case PICKUP_ONE:
+                                case PLACE_ALL:
+                                case PLACE_SOME:
+                                case PLACE_ONE:
+                                case SWAP_WITH_CURSOR:
+                                    this.player.networkHandler.sendPacket(new ScreenHandlerSlotUpdateS2CPacket(-1, -1, this.player.inventory.getCursorStack()));
+                                    this.player.networkHandler.sendPacket(new ScreenHandlerSlotUpdateS2CPacket(this.player.currentScreenHandler.syncId, clickwindowc2spacket.getSlot(), this.player.currentScreenHandler.getSlot(clickwindowc2spacket.getSlot()).getStack()));
+                                    break;
+                                // Modified clicked only
+                                case DROP_ALL_SLOT:
+                                case DROP_ONE_SLOT:
+                                    this.player.networkHandler.sendPacket(new ScreenHandlerSlotUpdateS2CPacket(this.player.currentScreenHandler.syncId, clickwindowc2spacket.getSlot(), this.player.currentScreenHandler.getSlot(clickwindowc2spacket.getSlot()).getStack()));
+                                    break;
+                                // Modified cursor only
+                                case DROP_ALL_CURSOR:
+                                case DROP_ONE_CURSOR:
+                                case CLONE_STACK:
+                                    this.player.networkHandler.sendPacket(new ScreenHandlerSlotUpdateS2CPacket(-1, -1, this.player.inventory.getCursorStack()));
+                                    break;
+                                // Nothing
+                                case NOTHING:
+                                    break;
+                            }
+                            return;
+                    }
+
+                    if (event instanceof CraftItemEvent) {
+                        // Need to update the inventory on crafting to
+                        // correctly support custom recipes
+                        player.openHandledScreen(player.currentScreenHandler);
+                    }
+                }
+                // CraftBukkit end
+                
                 if (ItemStack.areEqual(clickwindowc2spacket.getStack(), itemstack)) {
                     this.player.networkHandler.sendPacket(new ConfirmGuiActionS2CPacket(clickwindowc2spacket.getSyncId(), clickwindowc2spacket.getActionId(), true));
                     this.player.skipPacketSlotUpdates = true;
@@ -1291,6 +2307,7 @@
 
     public void onButtonClick(ButtonClickC2SPacket buttonclickc2spacket) {
         NetworkThreadUtils.forceMainThread(buttonclickc2spacket, this, this.player.getServerWorld());
+        if (this.player.isFrozen()) return; // CraftBukkit
         this.player.updateLastActionTime();
         if (this.player.currentScreenHandler.syncId == buttonclickc2spacket.getSyncId() && this.player.currentScreenHandler.isNotRestricted(this.player) && !this.player.isSpectator()) {
             this.player.currentScreenHandler.onButtonClick(this.player, buttonclickc2spacket.getButtonId());
@@ -1323,6 +2340,44 @@
             boolean flag1 = creativeinventoryactionc2spacket.getSlot() >= 1 && creativeinventoryactionc2spacket.getSlot() <= 45;
             boolean flag2 = itemstack.isEmpty() || itemstack.getDamage() >= 0 && itemstack.getCount() <= 64 && !itemstack.isEmpty();
 
+            if (flag || (flag1 && !ItemStack.areEqual(this.player.playerScreenHandler.getSlot(creativeinventoryactionc2spacket.getSlot()).getStack(), creativeinventoryactionc2spacket.getItemStack()))) { // Insist on valid slot
+                // CraftBukkit start - Call click event
+                InventoryView inventory = this.player.playerScreenHandler.getBukkitView();
+                org.bukkit.inventory.ItemStack item = CraftItemStack.asBukkitCopy(creativeinventoryactionc2spacket.getItemStack());
+
+                SlotType type = SlotType.QUICKBAR;
+                if (flag) {
+                    type = SlotType.OUTSIDE;
+                } else if (creativeinventoryactionc2spacket.getSlot() < 36) {
+                    if (creativeinventoryactionc2spacket.getSlot() >= 5 && creativeinventoryactionc2spacket.getSlot() < 9) {
+                        type = SlotType.ARMOR;
+                    } else {
+                        type = SlotType.CONTAINER;
+                    }
+                }
+                InventoryCreativeEvent event = new InventoryCreativeEvent(inventory, type, flag ? -999 : creativeinventoryactionc2spacket.getSlot(), item);
+                Bukkit.getPluginManager().callEvent(event);
+
+                itemstack = CraftItemStack.asNMSCopy(event.getCursor());
+
+                switch (event.getResult()) {
+                case ALLOW:
+                    // Plugin cleared the id / stacksize checks
+                    flag2 = true;
+                    break;
+                case DEFAULT:
+                    break;
+                case DENY:
+                    // Reset the slot
+                    if (creativeinventoryactionc2spacket.getSlot() >= 0) {
+                        this.player.networkHandler.sendPacket(new ScreenHandlerSlotUpdateS2CPacket(this.player.playerScreenHandler.syncId, creativeinventoryactionc2spacket.getSlot(), this.player.playerScreenHandler.getSlot(creativeinventoryactionc2spacket.getSlot()).getStack()));
+                        this.player.networkHandler.sendPacket(new ScreenHandlerSlotUpdateS2CPacket(-1, -1, ItemStack.EMPTY));
+                    }
+                    return;
+                }
+            }
+            // CraftBukkit end
+            
             if (flag1 && flag2) {
                 if (itemstack.isEmpty()) {
                     this.player.playerScreenHandler.setStackInSlot(creativeinventoryactionc2spacket.getSlot(), ItemStack.EMPTY);
@@ -1342,6 +2397,7 @@
 
     public void onConfirmTransaction(ConfirmGuiActionC2SPacket confirmguiactionc2spacket) {
         NetworkThreadUtils.forceMainThread(confirmguiactionc2spacket, this, this.player.getServerWorld());
+        if (this.player.isFrozen()) return; // CraftBukkit
         int i = this.player.currentScreenHandler.syncId;
 
         if (i == confirmguiactionc2spacket.getWindowId() && this.transactions.getOrDefault(i, (short) (confirmguiactionc2spacket.getSyncId() + 1)) == confirmguiactionc2spacket.getSyncId() && !this.player.currentScreenHandler.isNotRestricted(this.player) && !this.player.isSpectator()) {
@@ -1352,6 +2408,7 @@
 
     public void onSignUpdate(UpdateSignC2SPacket updatesignc2spacket) {
         NetworkThreadUtils.forceMainThread(updatesignc2spacket, this, this.player.getServerWorld());
+        if (this.player.isFrozen()) return; // CraftBukkit
         this.player.updateLastActionTime();
         ServerWorld serverworld = this.player.getServerWorld();
         BlockPos blockpos = updatesignc2spacket.getPos();
@@ -1368,14 +2425,31 @@
 
             if (!signblockentity.isEditable() || signblockentity.getEditor() != this.player) {
                 ServerPlayNetworkHandler.LOGGER.warn("Player {} just tried to change non-editable sign", (Object) this.player.getName().getString());
+                this.sendPacket(signblockentity.toUpdatePacket()); // CraftBukkit
                 return;
             }
 
             String[] astring = updatesignc2spacket.getText();
 
+            // CraftBukkit start
+            Player player = this.craftServer.getPlayer(this.player);
+            int x = updatesignc2spacket.getPos().getX();
+            int y = updatesignc2spacket.getPos().getY();
+            int z = updatesignc2spacket.getPos().getZ();
+            String[] lines = new String[4];
+
             for (int i = 0; i < astring.length; ++i) {
-                signblockentity.setTextOnRow(i, new LiteralText(Formatting.strip(astring[i])));
+                // signblockentity.setTextOnRow(i, new LiteralText(Formatting.strip(astring[i])));
+                lines[i] = Formatting.strip(new TranslatableText(Formatting.strip(astring[i])).getString());
             }
+            SignChangeEvent event = new SignChangeEvent((org.bukkit.craftbukkit.block.CraftBlock) player.getWorld().getBlockAt(x, y, z), this.craftServer.getPlayer(this.player), lines);
+            Bukkit.getPluginManager().callEvent(event);
+
+            if (!event.isCancelled()) {
+                System.arraycopy(org.bukkit.craftbukkit.block.CraftSign.sanitizeLines(event.getLines()), 0, signblockentity.text, 0, 4);
+                signblockentity.editable = false;
+             }
+            // CraftBukkit end
 
             signblockentity.markDirty();
             serverworld.updateListeners(blockpos, blockstate, blockstate, 3);
@@ -1384,6 +2458,7 @@
     }
 
     public void onKeepAlive(KeepAliveC2SPacket keepalivec2spacket) {
+        NetworkThreadUtils.forceMainThread(keepalivec2spacket, this, this.player.getServerWorld()); // CraftBukkit
         if (this.waitingForKeepAlive && keepalivec2spacket.getId() == this.keepAliveId) {
             int i = (int) (Util.getMeasuringTimeMs() - this.lastKeepAliveTime);
 
@@ -1397,7 +2472,18 @@
 
     public void onPlayerAbilities(UpdatePlayerAbilitiesC2SPacket updateplayerabilitiesc2spacket) {
         NetworkThreadUtils.forceMainThread(updateplayerabilitiesc2spacket, this, this.player.getServerWorld());
-        this.player.abilities.flying = updateplayerabilitiesc2spacket.isFlying() && this.player.abilities.allowFlying;
+        // this.player.abilities.flying = updateplayerabilitiesc2spacket.isFlying() && this.player.abilities.allowFlying;
+        // CraftBukkit start
+        if (this.player.abilities.allowFlying && this.player.abilities.flying != updateplayerabilitiesc2spacket.isFlying()) {
+            PlayerToggleFlightEvent event = new PlayerToggleFlightEvent(this.craftServer.getPlayer(this.player), updateplayerabilitiesc2spacket.isFlying());
+            Bukkit.getPluginManager().callEvent(event);
+            if (!event.isCancelled()) {
+                this.player.abilities.flying = updateplayerabilitiesc2spacket.isFlying(); // Actually set the player's flying status
+            } else {
+                this.player.sendAbilitiesUpdate(); // Tell the player their ability was reverted
+            }
+        }
+        // CraftBukkit end
     }
 
     public void onClientSettings(ClientSettingsC2SPacket clientsettingsc2spacket) {
@@ -1405,7 +2491,49 @@
         this.player.setClientSettings(clientsettingsc2spacket);
     }
 
-    public void onCustomPayload(CustomPayloadC2SPacket custompayloadc2spacket) {}
+    // CraftBukkit start
+    private static final Identifier CUSTOM_REGISTER = new Identifier("register");
+    private static final Identifier CUSTOM_UNREGISTER = new Identifier("unregister");
+
+    public void onCustomPayload(CustomPayloadC2SPacket custompayloadc2spacket) {
+        NetworkThreadUtils.forceMainThread(custompayloadc2spacket, this, this.player.getServerWorld());
+        if (custompayloadc2spacket.getChannel().equals(CUSTOM_REGISTER)) {
+            try {
+                String channels = custompayloadc2spacket.getData().toString(com.google.common.base.Charsets.UTF_8);
+                for (String channel : channels.split("\0")) {
+                    getPlayer().addChannel(channel);
+                }
+            } catch (Exception ex) {
+                ServerPlayNetworkHandler.LOGGER.error("Couldn\'t register custom payload", ex);
+                this.disconnect("Invalid payload REGISTER!");
+            }
+        } else if (custompayloadc2spacket.getChannel().equals(CUSTOM_UNREGISTER)) {
+            try {
+                String channels = custompayloadc2spacket.getData().toString(com.google.common.base.Charsets.UTF_8);
+                for (String channel : channels.split("\0")) {
+                    getPlayer().removeChannel(channel);
+                }
+            } catch (Exception ex) {
+                ServerPlayNetworkHandler.LOGGER.error("Couldn\'t unregister custom payload", ex);
+                this.disconnect("Invalid payload UNREGISTER!");
+            }
+        } else {
+            try {
+                byte[] data = new byte[custompayloadc2spacket.getData().readableBytes()];
+                custompayloadc2spacket.getData().readBytes(data);
+                craftServer.getMessenger().dispatchIncomingMessage(player.getBukkitEntity(), custompayloadc2spacket.getChannel().toString(), data);
+            } catch (Exception ex) {
+                ServerPlayNetworkHandler.LOGGER.error("Couldn\'t dispatch custom payload", ex);
+                this.disconnect("Invalid custom payload!");
+            }
+        }
+
+    }
+
+    public final boolean isDisconnected() {
+        return !this.player.joining && !this.connection.isOpen();
+    }
+    // CraftBukkit end
 
     public void onUpdateDifficulty(UpdateDifficultyC2SPacket updatedifficultyc2spacket) {
         NetworkThreadUtils.forceMainThread(updatedifficultyc2spacket, this, this.player.getServerWorld());
@@ -1420,4 +2548,10 @@
             this.server.setDifficultyLocked(updatedifficultylockc2spacket.isDifficultyLocked());
         }
     }
+
+    // CraftBukkit begin
+    public CraftPlayer getPlayer() {
+        return (this.player == null) ? null : (CraftPlayer) this.player.getBukkitEntity();
+    }
+    // CraftBukkit end
 }
